

补充结构知识：
1、数据库的设计和使用、
2、
3、
4、


学习Flask Web开发 基于Python的Web应用开发实战的总结，以整体理解的方式换了下例子
的顺序如果需要深入学习请访问其github

https://github.com/miguelgrinberg/flasky-first-edition
Flask Web Development by Miguel Grinberg(O'Reilly).
Copyright 2014 Miguel Grinberg, 978-1-449-3726-2

涉及方面：
模板的处理方式
用来处理HTML的等前端内容的表现形式，完成业务和UI的分离
Jinja2文档http://jinja.pocoo.org/docs

集成日期和时间的处理到Jinja2模板 Flask—Moment



表单交互
把类似报表形式的内容放在HTTP中传递，解决了协议传输等单调而重复的内容
Flask-WTF（http://pythonhosted.org/Flask-WTF）

CSRF攻击：
伪造一个提交链接，然后把链接发送到需要提交确认的用户，当用户点开链接的时候，如果该用户cookie
保存了授权信息且没有过期，那么该用户在不知情的情况下完成了一次确认行为


应用层叠样式表（CSS）和Javascript文件的HTML响应，并在HTML、CSS、Javascript（试图呈现的套路）
代码中实例化所需组件，最适合在模板中执行
Bootstrap文档http://getbootstrap.com

SQLAlchemy（http://www.sqlalchemy.org）


这段代码主要基于自己对Flask Web开发(狗书)的理解，将代码划分开来学习的
虚拟环境：
sudo apt-get install python-virtualenv
virtualenv venv
source venv/bin/activate

2018-5-19
//蓝本
1、每个界面的业务可以算是一个开端，以蓝本为基础，配合试图函数，可以处理一个单项业务。
如果有别的业务，再追加一个新业务视图文件夹

补充：蓝本的调用像嵌入式处理的注册
from . import views  //__init__完成一个蓝本，但是我不做处理，我只执行你要蓝本执行的工作
@main.route('/', methods = ['GET', 'POST']) //调用蓝本，准备注册自己要完成的功能

2018-5-20
shell
2、重新调整了一下结构，配置文件和readme应该是全文件夹的一个总结，所以放根目录了，flask界面程序的整合，
也放根目录。
flask.py 加入shell命令行，因为Flask_Script不再维护，所以使用最新的shell工具，该工具直接
集成在Flask中
@app.shell_context_processor

使用方法：
export FLASK_APP=flask.py(自己的应用文件flask.py)
flask shell

/×请求上下文、请求调度、请求钩子、响应，后续增加例子就在后面补充，涉及RESTFUL模型、HTTP协议和
上下文文管理×/

引入模板
3、在做一个项目的时候，如果业务和视图呈现不做区别，或者功能不模块化的话，会提高维护成本。出了问题，
错综复杂的纠葛，让人抓耳挠腮。flask引入Jinja2模板，将视图处理和业务处理分离
我在app文件夹下创建了templates，用来处理网页呈现。因为是针对所有网页的，所以放在APP文件夹下

在APP下创建templates文件夹遇到jinja2.exceptions.TemplateNotFound问题

犯了一个超低级错误，居然把python自带的__name__变量加了引号，太低级了，这样在调用蓝本路由的时候，
flask就不知道
在哪里找视图函数了,因为main = Blueprint("main", __name__) 蓝本可以根据第二个参数找到蓝本所在位置

user_bootstrap.html主要是用来呈现页面的，主要涉及前端的HTML，CSS和Javascript
引入了title（界面标题）、navbar（导航条）和content（界面主体）
后端需要处理前端传入的name参数

加入错误的路由处理
@main.app_errorhandler(500)  //500 HTTP协议中的状态码、404和403比较常见，e是异常信息,可以参阅python
异常信息处理，关于html则是直接引用原书的文件
def internal_server_error(e):
    return render_template('500.html'), 500

4、在title上加入了一个静态图片
{{ url_for('static', filename='favicon.ico') }}

5、在加入moment的时候，user_bootstrap.html会对base的部分功能重写，导致引入moment模块的时候，
把{% block page_content %}的调用写没了，目前只考虑添加功能，本质上模拟真实的迭代。bootstrap的是否
对父模板进行重写是需要好好考虑的
后端moment做了初始化，向模板开放moment类，渲染的时候把时间传入html，Html使用moment导入时间处理
moment(current_time).format('LLL')
moment(current_time).fromNow(refresh=True)


WTF表单处理
6、WTF使用密匙生成加密令牌保护表单
SECRET_KEY = os.environ.get('SECRET_KEY')

由于引入了配置处理的config.py，所以对于app下初始化的__init__.py也要引入配置内容
    app.config.from_object(Config)
    Config.init_app(app)
引入类方法init_app是为了和别的类处理方式上同步，以便后续添加功能

POST请求方法提交表单更加便利，因为GET请求没有主题可以在URL中显示出来

为了添加表单我做了以下工作
a）加入表单功能form.py,创建表单类
b）将表单功能服务于视图

由于刷新页面时，浏览器会重新发送之前发送的最后一个请求，所以最好别让Web程序把POST请求作为浏览器发送的最后
一个请求。那就引入了重定向响应。但是重定向会丢失上一个请求的数据，所以需要使用sessoin（用户会话，请求上下文中的
变量）。session是cookie的一部分知识

在模板中使用循环是因为在之前的请求循环中每次调用flash函数时都会生成一个消息，可能多个消息在排队等待显示
get_flashed_messages()函数获取的消息不会在下次调用时返回

7、数据库
关系型数据库
可以读MYSQL必知必会，不过可能永不到低层的东西
MYSQL是关系型数据库，很多时候需要做联结操作。主键作为唯一的标识，通常一定要不具备特殊的意义。
通过外键可以将两个表关联起来，当成EXCEL关联数据去理解也可以。

在使用MYSQL的时候要注意不同表之间的联系，在设计的时候避免重复，以此来保证数据的一致性。
通常检查某项数据可以获取到很多关联信息，但是对于描述一个详细的事物过于抽象

非关系型数据库
一般用mongdb的比较多，
在使用mongdb的时候，放宽了一致性的要求，从而获得性能上的优势。而且查询事物内容比较详细
但是会有很多重复量，因为同一类事物，并没有进行高度的抽象。

Flask使用了 SQLAlchemy ORM来支持关系型数据库引擎，可以支持很多关系型数据库，后续改进的时候会使用MYYSQL数据库

数据库的使用：
    配置数据库的位置，如果有固定位置可以export DEV_DATABASE_URL
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or
    'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')

    //每次请求结束后自动提交数据库变动
    SQLALCHEMY_COMMIT_ON_TEARDOWN = True

    初始化app服务的时候加入SQLAlchemy的功能，实例化为db

    定义了两个数据库模型
    Role
    可以理解为角色，比如管理员、会员、普通用户
    User
    可以理解为身份证、本身不代表身份的象征，指标是一种通用的指带

    模型是数据所有视图所共用的，所以放在APP文件夹下

    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    User 类的role_id 通过外键和roles表的id建立映射关系
    users = db.relationship('User', backref='role', lazy='dynamic')

    Role模型使users和USER模型建立关系，访问users即对USER模型整体的访问
    backref 则通过在USER模型中，创建role变量，使USER模型通过访问role变量，来访问ROLE模型的整体
    通过下面打印的数据库查询内容，可以确认relationship是根据外键role_id建立起来的整个USER模型的访问

    Role类的users通过反向引用，自行找到满足外键关系的过滤条件,获取外键所在的整个模型，
    即relationship和外键建立一对多的关系
    print(User实例.users)
    SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id
    FROM users
    WHERE :param_1 = users.role_id
    没有提交到数据库中时，主键和外键均未生效

    在db.session.commit()的时候
    sqlalchemy.exc.InvalidRequestError: This Session's transaction has been rolled back due to a previous exception during flush. To begin a new transaction with this Session, first issue Session.rollback(). Original exception was: (sqlite3.OperationalError) no such table: roles [SQL: 'INSERT INTO roles (name) VALUES (?)'] [parameters: ('Admin',)]
    提交失败、建议回滚
    db.session.rollback()  //能解决很多问题

    提交单个信息收到这个
    sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: roles [SQL:
    'INSERT INTO roles (name) VALUES (?)'] [parameters: ('Admin',)]

    主要是因为我之前db.create_all()的时候，文件夹内生成了数据库文件。我尝试把数据库中的表db.drop_all()
    清除之后观察是否删除数据库的原因，再次调用db.create_all()的时候，没有创建USER和Role列

    一切都提交正确的情况下
    >>> print(admin_role.id)
    1
    >>> print(admin_role.users)
    SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id
    FROM users
    WHERE ? = users.role_id
    relationship通过users建立多对以关系，以外键为筛选对象

    >>> print(user_john.role_id)
    1
    >>> print(user_susan.role_id)
    3
    >>>
    外键和ID关联

    Role.query.all()
    query.all查询所有返回值

    增加：
    add commit
    删除：
    delete commit
    修改：
    修改 add commit

    主键是由SQLAlchemy来维护的

    用户提交的数据会保存在USER模型中，后期完成注册功能的时候也会用到。




















关于HTML：
HTML是一种文本解释性语言，通过标签的形式，完成网页的呈现。学得快，忘的不比学得慢。
个人感觉HTML的主要功力在于视觉的设计上，而不是语言本身，后面学到的模板会记录到这里.
引用于http://www.w3school.com.cn
Jinja2文档http://jinja.pocoo.org/docs
模板的处理方式
选择语句：
{% if ? %}

{% else %}

{% endif %}

循环语句：
{% for comment in comments %}

{% endfor %}

宏定义:
{% marco 宏定义%}
    宏定义实体
{% end marco %}

导入、包含和衍生：
{% import ‘base.html’ as base %}
{% include 'common.html' %}
{% extends "base.html" %}

关于Bootstrap中的styles和scripts块生命，如果程序需要像已有内容添加新内容
{{ super() }
新增内容
其实就是继承了父类的属性和功能。


